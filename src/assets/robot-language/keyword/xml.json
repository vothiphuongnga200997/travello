{
    "name": "XML",
    "version": "3.0.4",
    "keywords": [
        {
            "name": "Add Element",
            "args": [
                "source",
                "element",
                "index=None",
                "xpath=."
            ],
            "doc": "Adds a child element to the specified element.\n\nThe element to whom to add the new element is specified using `source` and `xpath`. They have exactly the same semantics as with [Get Element](#Get%20Element) keyword. The resulting XML structure is returned, and if the `source` is an already parsed XML structure, it is also modified in place.\n\nThe `element` to add can be specified as a path to an XML file or as a string containing XML, or it can be an already parsed XML element. The element is copied before adding so modifying either the original or the added element has no effect on the other . The element is added as the last child by default, but a custom index can be used to alter the position. Indices start from zero (0 = first position, 1 = second position, etc.), and negative numbers refer to positions at the end (-1 = second last position, -2 = third last, etc.).\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\nAdd Element  ${XML}  <new id=\"x\"><c1/></new>    \nAdd Element  ${XML}  <c2/>  xpath=new  \nAdd Element  ${XML}  <c3/>  index=1  xpath=new\n${new} =  Get Element  ${XML}  new  \nElements Should Be Equal  ${new}  <new id=\"x\"><c1/><c3/><c2/></new>    \n```\n\nUse [Remove Element](#Remove%20Element) or [Remove Elements](#Remove%20Elements) to remove elements."
        },
        {
            "name": "Clear Element",
            "args": [
                "source",
                "xpath=.",
                "clear_tail=False"
            ],
            "doc": "Clears the contents of the specified element.\n\nThe element to clear is specified using `source` and `xpath`. They have exactly the same semantics as with [Get Element](#Get%20Element) keyword. The resulting XML structure is returned, and if the `source` is an already parsed XML structure, it is also modified in place.\n\nClearing the element means removing its text, attributes, and children. Element's tail text is not removed by default, but that can be changed by giving `clear_tail` a true value (see [Boolean arguments](#Boolean%20arguments)). See [Element attributes](#Element%20attributes) section for more information about tail in general.\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\nClear Element  ${XML}  xpath=first    \n${first} =  Get Element  ${XML}  xpath=first  \nElements Should Be Equal  ${first}  <first/>    \nClear Element  ${XML}  xpath=html/p/b  clear_tail=yes  \nElement Text Should Be  ${XML}  Text with italics.  xpath=html/p  normalize_whitespace=yes\nClear Element  ${XML}      \nElements Should Be Equal  ${XML}  <example/>    \n```\n\nUse [Remove Element](#Remove%20Element) to remove the whole element."
        },
        {
            "name": "Copy Element",
            "args": [
                "source",
                "xpath=."
            ],
            "doc": "Returns a copy of the specified element.\n\nThe element to copy is specified using `source` and `xpath`. They have exactly the same semantics as with [Get Element](#Get%20Element) keyword.\n\nIf the copy or the original element is modified afterwards, the changes have no effect on the other.\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\n${elem} =  Get Element  ${XML}  xpath=first\n${copy1} =  Copy Element  ${elem}  \n${copy2} =  Copy Element  ${XML}  xpath=first\nSet Element Text  ${XML}  new text  xpath=first\nSet Element Attribute  ${copy1}  id  new\nElements Should Be Equal  ${elem}  <first id=\"1\">new text</first>  \nElements Should Be Equal  ${copy1}  <first id=\"new\">text</first>  \nElements Should Be Equal  ${copy2}  <first id=\"1\">text</first>  \n```"
        },
        {
            "name": "Element Attribute Should Be",
            "args": [
                "source",
                "name",
                "expected",
                "xpath=.",
                "message=None"
            ],
            "doc": "Verifies that the specified attribute is `expected`.\n\nThe element whose attribute is verified is specified using `source` and `xpath`. They have exactly the same semantics as with [Get Element](#Get%20Element) keyword.\n\nThe keyword passes if the attribute `name` of the element is equal to the `expected` value, and otherwise it fails. The default error message can be overridden with the `message` argument.\n\nTo test that the element does not have a certain attribute, Python `None` (i.e. variable `${NONE}`) can be used as the expected value. A cleaner alternative is using [Element Should Not Have Attribute](#Element%20Should%20Not%20Have%20Attribute).\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\nElement Attribute Should Be  ${XML}  id  1  xpath=first\nElement Attribute Should Be  ${XML}  id  ${NONE}  \n```\n\nSee also [Element Attribute Should Match](#Element%20Attribute%20Should%20Match) and [Get Element Attribute](#Get%20Element%20Attribute)."
        },
        {
            "name": "Element Attribute Should Match",
            "args": [
                "source",
                "name",
                "pattern",
                "xpath=.",
                "message=None"
            ],
            "doc": "Verifies that the specified attribute matches `expected`.\n\nThis keyword works exactly like [Element Attribute Should Be](#Element%20Attribute%20Should%20Be) except that the expected value can be given as a pattern that the attribute of the element must match.\n\nPattern matching is similar as matching files in a shell, and it is always case-sensitive. In the pattern, '\\*' matches anything and '?' matches any single character.\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\nElement Attribute Should Match  ${XML}  id  ?  xpath=first\nElement Attribute Should Match  ${XML}  id  c*d  xpath=third/second\n```"
        },
        {
            "name": "Element Should Exist",
            "args": [
                "source",
                "xpath=.",
                "message=None"
            ],
            "doc": "Verifies that one or more element match the given `xpath`.\n\nArguments `source` and `xpath` have exactly the same semantics as with [Get Elements](#Get%20Elements) keyword. Keyword passes if the `xpath` matches one or more elements in the `source`. The default error message can be overridden with the `message` argument.\n\nSee also [Element Should Not Exist](#Element%20Should%20Not%20Exist) as well as [Get Element Count](#Get%20Element%20Count) that this keyword uses internally."
        },
        {
            "name": "Element Should Not Exist",
            "args": [
                "source",
                "xpath=.",
                "message=None"
            ],
            "doc": "Verifies that no element match the given `xpath`.\n\nArguments `source` and `xpath` have exactly the same semantics as with [Get Elements](#Get%20Elements) keyword. Keyword fails if the `xpath` matches any element in the `source`. The default error message can be overridden with the `message` argument.\n\nSee also [Element Should Exist](#Element%20Should%20Exist) as well as [Get Element Count](#Get%20Element%20Count) that this keyword uses internally."
        },
        {
            "name": "Element Should Not Have Attribute",
            "args": [
                "source",
                "name",
                "xpath=.",
                "message=None"
            ],
            "doc": "Verifies that the specified element does not have attribute `name`.\n\nThe element whose attribute is verified is specified using `source` and `xpath`. They have exactly the same semantics as with [Get Element](#Get%20Element) keyword.\n\nThe keyword fails if the specified element has attribute `name`. The default error message can be overridden with the `message` argument.\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\nElement Should Not Have Attribute  ${XML}  id  \nElement Should Not Have Attribute  ${XML}  xxx  xpath=first\n```\n\nSee also [Get Element Attribute](#Get%20Element%20Attribute), [Get Element Attributes](#Get%20Element%20Attributes), [Element Text Should Be](#Element%20Text%20Should%20Be) and [Element Text Should Match](#Element%20Text%20Should%20Match)."
        },
        {
            "name": "Element Text Should Be",
            "args": [
                "source",
                "expected",
                "xpath=.",
                "normalize_whitespace=False",
                "message=None"
            ],
            "doc": "Verifies that the text of the specified element is `expected`.\n\nThe element whose text is verified is specified using `source` and `xpath`. They have exactly the same semantics as with [Get Element](#Get%20Element) keyword.\n\nThe text to verify is got from the specified element using the same logic as with [Get Element Text](#Get%20Element%20Text). This includes optional whitespace normalization using the `normalize_whitespace` option.\n\nThe keyword passes if the text of the element is equal to the `expected` value, and otherwise it fails. The default error message can be overridden with the `message` argument. Use [Element Text Should Match](#Element%20Text%20Should%20Match) to verify the text against a pattern instead of an exact value.\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\nElement Text Should Be  ${XML}  text  xpath=first\nElement Text Should Be  ${XML}  ${EMPTY}  xpath=second/child\n${paragraph} =  Get Element  ${XML}  xpath=html/p\nElement Text Should Be  ${paragraph}  Text with bold and italics.  normalize_whitespace=yes\n```"
        },
        {
            "name": "Element Text Should Match",
            "args": [
                "source",
                "pattern",
                "xpath=.",
                "normalize_whitespace=False",
                "message=None"
            ],
            "doc": "Verifies that the text of the specified element matches `expected`.\n\nThis keyword works exactly like [Element Text Should Be](#Element%20Text%20Should%20Be) except that the expected value can be given as a pattern that the text of the element must match.\n\nPattern matching is similar as matching files in a shell, and it is always case-sensitive. In the pattern, '\\*' matches anything and '?' matches any single character.\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\nElement Text Should Match  ${XML}  t???  xpath=first\n${paragraph} =  Get Element  ${XML}  xpath=html/p\nElement Text Should Match  ${paragraph}  Text with * and *.  normalize_whitespace=yes\n```"
        },
        {
            "name": "Element To String",
            "args": [
                "source",
                "xpath=.",
                "encoding=None"
            ],
            "doc": "Returns the string representation of the specified element.\n\nThe element to convert to a string is specified using `source` and `xpath`. They have exactly the same semantics as with [Get Element](#Get%20Element) keyword.\n\nBy default the string is returned as Unicode. If `encoding` argument is given any value, the string is returned as bytes in the specified encoding. The resulting string never contains the XML declaration.\n\nSee also [Log Element](#Log%20Element) and [Save XML](#Save%20Xml)."
        },
        {
            "name": "Elements Should Be Equal",
            "args": [
                "source",
                "expected",
                "exclude_children=False",
                "normalize_whitespace=False"
            ],
            "doc": "Verifies that the given `source` element is equal to `expected`.\n\nBoth `source` and `expected` can be given as a path to an XML file, as a string containing XML, or as an already parsed XML element structure. See [introduction](#Introduction) for more information about parsing XML in general.\n\nThe keyword passes if the `source` element and `expected` element are equal. This includes testing the tag names, texts, and attributes of the elements. By default also child elements are verified the same way, but this can be disabled by setting `exclude_children` to a true value (see [Boolean arguments](#Boolean%20arguments)).\n\nAll texts inside the given elements are verified, but possible text outside them is not. By default texts must match exactly, but setting `normalize_whitespace` to a true value makes text verification independent on newlines, tabs, and the amount of spaces. For more details about handling text see [Get Element Text](#Get%20Element%20Text) keyword and discussion about elements' [text](#text) and [tail](#tail) attributes in the [introduction](#Introduction).\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\n${first} =  Get Element  ${XML}  first  \nElements Should Be Equal  ${first}  <first id=\"1\">text</first>    \n${p} =  Get Element  ${XML}  html/p  \nElements Should Be Equal  ${p}  <p>Text with <b>bold</b> and <i>italics</i>.</p>  normalize_whitespace=yes  \nElements Should Be Equal  ${p}  <p>Text with</p>  exclude  normalize\n```\n\nThe last example may look a bit strange because the `<p>` element only has text `Text with`. The reason is that rest of the text inside `<p>` actually belongs to the child elements. This includes the `.` at the end that is the [tail](#tail) text of the `<i>` element.\n\nSee also [Elements Should Match](#Elements%20Should%20Match)."
        },
        {
            "name": "Elements Should Match",
            "args": [
                "source",
                "expected",
                "exclude_children=False",
                "normalize_whitespace=False"
            ],
            "doc": "Verifies that the given `source` element matches `expected`.\n\nThis keyword works exactly like [Elements Should Be Equal](#Elements%20Should%20Be%20Equal) except that texts and attribute values in the expected value can be given as patterns.\n\nPattern matching is similar as matching files in a shell, and it is always case-sensitive. In the pattern, '\\*' matches anything and '?' matches any single character.\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\n${first} =  Get Element  ${XML}  first\nElements Should Match  ${first}  <first id=\"?\">*</first>  \n```\n\nSee [Elements Should Be Equal](#Elements%20Should%20Be%20Equal) for more examples."
        },
        {
            "name": "Evaluate Xpath",
            "args": [
                "source",
                "expression",
                "context=."
            ],
            "doc": "Evaluates the given xpath expression and returns results.\n\nThe element in which context the expression is executed is specified using `source` and `context` arguments. They have exactly the same semantics as `source` and `xpath` arguments have with [Get Element](#Get%20Element) keyword.\n\nThe xpath expression to evaluate is given as `expression` argument. The result of the evaluation is returned as-is.\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\n${count} =  Evaluate Xpath  ${XML}  count(third/*)  \nShould Be Equal  ${count}  ${3}    \n${text} =  Evaluate Xpath  ${XML}  string(descendant::second[last()]/@id)  \nShould Be Equal  ${text}  child    \n${bold} =  Evaluate Xpath  ${XML}  boolean(preceding-sibling::*[1] = 'bold')  context=html/p/i\nShould Be Equal  ${bold}  ${True}    \n```\n\nThis keyword works only if lxml mode is taken into use when [importing](#Importing) the library. New in Robot Framework 2.8.5."
        },
        {
            "name": "Get Child Elements",
            "args": [
                "source",
                "xpath=."
            ],
            "doc": "Returns the child elements of the specified element as a list.\n\nThe element whose children to return is specified using `source` and `xpath`. They have exactly the same semantics as with [Get Element](#Get%20Element) keyword.\n\nAll the direct child elements of the specified element are returned. If the element has no children, an empty list is returned.\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\n${children} =  Get Child Elements  ${XML}  \nLength Should Be  ${children}  4  \n${children} =  Get Child Elements  ${XML}  xpath=first\nShould Be Empty  ${children}    \n```"
        },
        {
            "name": "Get Element",
            "args": [
                "source",
                "xpath=."
            ],
            "doc": "Returns an element in the `source` matching the `xpath`.\n\nThe `source` can be a path to an XML file, a string containing XML, or an already parsed XML element. The `xpath` specifies which element to find. See the [introduction](#Introduction) for more details about both the possible sources and the supported xpath syntax.\n\nThe keyword fails if more, or less, than one element matches the `xpath`. Use [Get Elements](#Get%20Elements) if you want all matching elements to be returned.\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\n${element} =  Get Element  ${XML}  second\n${child} =  Get Element  ${element}  child\n```\n\n[Parse XML](#Parse%20Xml) is recommended for parsing XML when the whole structure is needed. It must be used if there is a need to configure how XML namespaces are handled.\n\nMany other keywords use this keyword internally, and keywords modifying XML are typically documented to both to modify the given source and to return it. Modifying the source does not apply if the source is given as a string. The XML structure parsed based on the string and then modified is nevertheless returned."
        },
        {
            "name": "Get Element Attribute",
            "args": [
                "source",
                "name",
                "xpath=.",
                "default=None"
            ],
            "doc": "Returns the named attribute of the specified element.\n\nThe element whose attribute to return is specified using `source` and `xpath`. They have exactly the same semantics as with [Get Element](#Get%20Element) keyword.\n\nThe value of the attribute `name` of the specified element is returned. If the element does not have such element, the `default` value is returned instead.\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\n${attribute} =  Get Element Attribute  ${XML}  id  xpath=first  \nShould Be Equal  ${attribute}  1      \n${attribute} =  Get Element Attribute  ${XML}  xx  xpath=first  default=value\nShould Be Equal  ${attribute}  value      \n```\n\nSee also [Get Element Attributes](#Get%20Element%20Attributes), [Element Attribute Should Be](#Element%20Attribute%20Should%20Be), [Element Attribute Should Match](#Element%20Attribute%20Should%20Match) and [Element Should Not Have Attribute](#Element%20Should%20Not%20Have%20Attribute)."
        },
        {
            "name": "Get Element Attributes",
            "args": [
                "source",
                "xpath=."
            ],
            "doc": "Returns all attributes of the specified element.\n\nThe element whose attributes to return is specified using `source` and `xpath`. They have exactly the same semantics as with [Get Element](#Get%20Element) keyword.\n\nAttributes are returned as a Python dictionary. It is a copy of the original attributes so modifying it has no effect on the XML structure.\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\n${attributes} =  Get Element Attributes  ${XML}  first\nDictionary Should Contain Key  ${attributes}  id  \n${attributes} =  Get Element Attributes  ${XML}  third\nShould Be Empty  ${attributes}    \n```\n\nUse [Get Element Attribute](#Get%20Element%20Attribute) to get the value of a single attribute."
        },
        {
            "name": "Get Element Count",
            "args": [
                "source",
                "xpath=."
            ],
            "doc": "Returns and logs how many elements the given `xpath` matches.\n\nArguments `source` and `xpath` have exactly the same semantics as with [Get Elements](#Get%20Elements) keyword that this keyword uses internally.\n\nSee also [Element Should Exist](#Element%20Should%20Exist) and [Element Should Not Exist](#Element%20Should%20Not%20Exist)."
        },
        {
            "name": "Get Element Text",
            "args": [
                "source",
                "xpath=.",
                "normalize_whitespace=False"
            ],
            "doc": "Returns all text of the element, possibly whitespace normalized.\n\nThe element whose text to return is specified using `source` and `xpath`. They have exactly the same semantics as with [Get Element](#Get%20Element) keyword.\n\nThis keyword returns all the text of the specified element, including all the text its children and grandchildren contain. If the element has no text, an empty string is returned. The returned text is thus not always the same as the [text](#text) attribute of the element.\n\nBy default all whitespace, including newlines and indentation, inside the element is returned as-is. If `normalize_whitespace` is given a true value (see [Boolean arguments](#Boolean%20arguments)), then leading and trailing whitespace is stripped, newlines and tabs converted to spaces, and multiple spaces collapsed into one. This is especially useful when dealing with HTML data.\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\n${text} =  Get Element Text  ${XML}  first\nShould Be Equal  ${text}  text  \n${text} =  Get Element Text  ${XML}  second/child\nShould Be Empty  ${text}    \n${paragraph} =  Get Element  ${XML}  html/p\n${text} =  Get Element Text  ${paragraph}  normalize_whitespace=yes\nShould Be Equal  ${text}  Text with bold and italics.  \n```\n\nSee also [Get Elements Texts](#Get%20Elements%20Texts), [Element Text Should Be](#Element%20Text%20Should%20Be) and [Element Text Should Match](#Element%20Text%20Should%20Match)."
        },
        {
            "name": "Get Elements",
            "args": [
                "source",
                "xpath"
            ],
            "doc": "Returns a list of elements in the `source` matching the `xpath`.\n\nThe `source` can be a path to an XML file, a string containing XML, or an already parsed XML element. The `xpath` specifies which element to find. See the [introduction](#Introduction) for more details.\n\nElements matching the `xpath` are returned as a list. If no elements match, an empty list is returned. Use [Get Element](#Get%20Element) if you want to get exactly one match.\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\n${children} =  Get Elements  ${XML}  third/child\nLength Should Be  ${children}  2  \n${children} =  Get Elements  ${XML}  first/child\nShould Be Empty  ${children}    \n```"
        },
        {
            "name": "Get Elements Texts",
            "args": [
                "source",
                "xpath",
                "normalize_whitespace=False"
            ],
            "doc": "Returns text of all elements matching `xpath` as a list.\n\nThe elements whose text to return is specified using `source` and `xpath`. They have exactly the same semantics as with [Get Elements](#Get%20Elements) keyword.\n\nThe text of the matched elements is returned using the same logic as with [Get Element Text](#Get%20Element%20Text). This includes optional whitespace normalization using the `normalize_whitespace` option.\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\n@{texts} =  Get Elements Texts  ${XML}  third/child\nLength Should Be  ${texts}  2  \nShould Be Equal  @{texts}[0]  more text  \nShould Be Equal  @{texts}[1]  ${EMPTY}  \n```"
        },
        {
            "name": "Log Element",
            "args": [
                "source",
                "level=INFO",
                "xpath=."
            ],
            "doc": "Logs the string representation of the specified element.\n\nThe element specified with `source` and `xpath` is first converted into a string using [Element To String](#Element%20To%20String) keyword internally. The resulting string is then logged using the given `level`.\n\nThe logged string is also returned."
        },
        {
            "name": "Parse Xml",
            "args": [
                "source",
                "keep_clark_notation=False",
                "strip_namespaces=False"
            ],
            "doc": "Parses the given XML file or string into an element structure.\n\nThe `source` can either be a path to an XML file or a string containing XML. In both cases the XML is parsed into ElementTree [element structure](http://docs.python.org/library/xml.etree.elementtree.html#xml.etree.ElementTree.Element) and the root element is returned. Possible comments and processing instructions in the source XML are removed.\n\nAs discussed in [Handling XML namespaces](#Handling%20XML%20namespaces) section, this keyword, by default, removes namespace information ElementTree has added to tag names and moves it into `xmlns` attributes. This typically eases handling XML documents with namespaces considerably. If you do not want that to happen, or want to avoid the small overhead of going through the element structure when your XML does not have namespaces, you can disable this feature by giving `keep_clark_notation` argument a true value (see [Boolean arguments](#Boolean%20arguments)).\n\nIf you want to strip namespace information altogether so that it is not included even if XML is saved, you can give a true value to `strip_namespaces` argument. This functionality is new in Robot Framework 3.0.2.\n\nExamples:\n\n```\n${root} =  Parse XML  <root><child/></root>  \n${xml} =  Parse XML  ${CURDIR}/test.xml  keep_clark_notation=True\n${xml} =  Parse XML  ${CURDIR}/test.xml  strip_namespaces=True\n```\n\nUse [Get Element](#Get%20Element) keyword if you want to get a certain element and not the whole structure. See [Parsing XML](#Parsing%20XML) section for more details and examples."
        },
        {
            "name": "Remove Element",
            "args": [
                "source",
                "xpath=",
                "remove_tail=False"
            ],
            "doc": "Removes the element matching `xpath` from the `source` structure.\n\nThe element to remove from the `source` is specified with `xpath` using the same semantics as with [Get Element](#Get%20Element) keyword. The resulting XML structure is returned, and if the `source` is an already parsed XML structure, it is also modified in place.\n\nThe keyword fails if `xpath` does not match exactly one element. Use [Remove Elements](#Remove%20Elements) to remove all matched elements.\n\nElement's tail text is not removed by default, but that can be changed by giving `remove_tail` a true value (see [Boolean arguments](#Boolean%20arguments)). See [Element attributes](#Element%20attributes) section for more information about [tail](#tail) in general.\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\nRemove Element  ${XML}  xpath=second    \nElement Should Not Exist  ${XML}  xpath=second    \nRemove Element  ${XML}  xpath=html/p/b  remove_tail=yes  \nElement Text Should Be  ${XML}  Text with italics.  xpath=html/p  normalize_whitespace=yes\n```"
        },
        {
            "name": "Remove Element Attribute",
            "args": [
                "source",
                "name",
                "xpath=."
            ],
            "doc": "Removes attribute `name` from the specified element.\n\nThe element whose attribute to remove is specified using `source` and `xpath`. They have exactly the same semantics as with [Get Element](#Get%20Element) keyword. The resulting XML structure is returned, and if the `source` is an already parsed XML structure, it is also modified in place.\n\nIt is not a failure to remove a non-existing attribute. Use [Remove Element Attributes](#Remove%20Element%20Attributes) to remove all attributes and [Set Element Attribute](#Set%20Element%20Attribute) to set them.\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\nRemove Element Attribute  ${XML}  id  xpath=first\nElement Should Not Have Attribute  ${XML}  id  xpath=first\n```\n\nCan only remove an attribute from a single element. Use [Remove Elements Attribute](#Remove%20Elements%20Attribute) to remove an attribute of multiple elements in one call."
        },
        {
            "name": "Remove Element Attributes",
            "args": [
                "source",
                "xpath=."
            ],
            "doc": "Removes all attributes from the specified element.\n\nThe element whose attributes to remove is specified using `source` and `xpath`. They have exactly the same semantics as with [Get Element](#Get%20Element) keyword. The resulting XML structure is returned, and if the `source` is an already parsed XML structure, it is also modified in place.\n\nUse [Remove Element Attribute](#Remove%20Element%20Attribute) to remove a single attribute and [Set Element Attribute](#Set%20Element%20Attribute) to set them.\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\nRemove Element Attributes  ${XML}  xpath=first  \nElement Should Not Have Attribute  ${XML}  id  xpath=first\n```\n\nCan only remove attributes from a single element. Use [Remove Elements Attributes](#Remove%20Elements%20Attributes) to remove all attributes of multiple elements in one call."
        },
        {
            "name": "Remove Elements",
            "args": [
                "source",
                "xpath=",
                "remove_tail=False"
            ],
            "doc": "Removes all elements matching `xpath` from the `source` structure.\n\nThe elements to remove from the `source` are specified with `xpath` using the same semantics as with [Get Elements](#Get%20Elements) keyword. The resulting XML structure is returned, and if the `source` is an already parsed XML structure, it is also modified in place.\n\nIt is not a failure if `xpath` matches no elements. Use [Remove Element](#Remove%20Element) to remove exactly one element.\n\nElement's tail text is not removed by default, but that can be changed by using `remove_tail` argument similarly as with [Remove Element](#Remove%20Element).\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\nRemove Elements  ${XML}  xpath=*/child\nElement Should Not Exist  ${XML}  xpath=second/child\nElement Should Not Exist  ${XML}  xpath=third/child\n```"
        },
        {
            "name": "Remove Elements Attribute",
            "args": [
                "source",
                "name",
                "xpath=."
            ],
            "doc": "Removes attribute `name` from the specified elements.\n\nLike [Remove Element Attribute](#Remove%20Element%20Attribute) but removes the attribute of all elements matching the given `xpath`.\n\nNew in Robot Framework 2.8.6."
        },
        {
            "name": "Remove Elements Attributes",
            "args": [
                "source",
                "xpath=."
            ],
            "doc": "Removes all attributes from the specified elements.\n\nLike [Remove Element Attributes](#Remove%20Element%20Attributes) but removes all attributes of all elements matching the given `xpath`.\n\nNew in Robot Framework 2.8.6."
        },
        {
            "name": "Save Xml",
            "args": [
                "source",
                "path",
                "encoding=UTF-8"
            ],
            "doc": "Saves the given element to the specified file.\n\nThe element to save is specified with `source` using the same semantics as with [Get Element](#Get%20Element) keyword.\n\nThe file where the element is saved is denoted with `path` and the encoding to use with `encoding`. The resulting file always contains the XML declaration.\n\nThe resulting XML file may not be exactly the same as the original:\n\n*   Comments and processing instructions are always stripped.\n*   Possible doctype and namespace prefixes are only preserved when [using lxml](#Using%20lxml).\n*   Other small differences are possible depending on the ElementTree or lxml version.\n\nUse [Element To String](#Element%20To%20String) if you just need a string representation of the element."
        },
        {
            "name": "Set Element Attribute",
            "args": [
                "source",
                "name",
                "value",
                "xpath=."
            ],
            "doc": "Sets attribute `name` of the specified element to `value`.\n\nThe element whose attribute to set is specified using `source` and `xpath`. They have exactly the same semantics as with [Get Element](#Get%20Element) keyword. The resulting XML structure is returned, and if the `source` is an already parsed XML structure, it is also modified in place.\n\nIt is possible to both set new attributes and to overwrite existing. Use [Remove Element Attribute](#Remove%20Element%20Attribute) or [Remove Element Attributes](#Remove%20Element%20Attributes) for removing them.\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\nSet Element Attribute  ${XML}  attr  value  \nElement Attribute Should Be  ${XML}  attr  value  \nSet Element Attribute  ${XML}  id  new  xpath=first\nElement Attribute Should Be  ${XML}  id  new  xpath=first\n```\n\nCan only set an attribute of a single element. Use [Set Elements Attribute](#Set%20Elements%20Attribute) to set an attribute of multiple elements in one call."
        },
        {
            "name": "Set Element Tag",
            "args": [
                "source",
                "tag",
                "xpath=."
            ],
            "doc": "Sets the tag of the specified element.\n\nThe element whose tag to set is specified using `source` and `xpath`. They have exactly the same semantics as with [Get Element](#Get%20Element) keyword. The resulting XML structure is returned, and if the `source` is an already parsed XML structure, it is also modified in place.\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\nSet Element Tag  ${XML}  newTag  \nShould Be Equal  ${XML.tag}  newTag  \nSet Element Tag  ${XML}  xxx  xpath=second/child\nElement Should Exist  ${XML}  second/xxx  \nElement Should Not Exist  ${XML}  second/child  \n```\n\nCan only set the tag of a single element. Use [Set Elements Tag](#Set%20Elements%20Tag) to set the tag of multiple elements in one call."
        },
        {
            "name": "Set Element Text",
            "args": [
                "source",
                "text=None",
                "tail=None",
                "xpath=."
            ],
            "doc": "Sets text and/or tail text of the specified element.\n\nThe element whose text to set is specified using `source` and `xpath`. They have exactly the same semantics as with [Get Element](#Get%20Element) keyword. The resulting XML structure is returned, and if the `source` is an already parsed XML structure, it is also modified in place.\n\nElement's text and tail text are changed only if new `text` and/or `tail` values are given. See [Element attributes](#Element%20attributes) section for more information about [text](#text) and [tail](#tail) in general.\n\nExamples using `${XML}` structure from [Example](#Example):\n\n```\nSet Element Text  ${XML}  new text  xpath=first  \nElement Text Should Be  ${XML}  new text  xpath=first  \nSet Element Text  ${XML}  tail=&  xpath=html/p/b  \nElement Text Should Be  ${XML}  Text with bold&italics.  xpath=html/p  normalize_whitespace=yes\nSet Element Text  ${XML}  slanted  !!  xpath=html/p/i\nElement Text Should Be  ${XML}  Text with bold&slanted!!  xpath=html/p  normalize_whitespace=yes\n```\n\nCan only set the text/tail of a single element. Use [Set Elements Text](#Set%20Elements%20Text) to set the text/tail of multiple elements in one call."
        },
        {
            "name": "Set Elements Attribute",
            "args": [
                "source",
                "name",
                "value",
                "xpath=."
            ],
            "doc": "Sets attribute `name` of the specified elements to `value`.\n\nLike [Set Element Attribute](#Set%20Element%20Attribute) but sets the attribute of all elements matching the given `xpath`.\n\nNew in Robot Framework 2.8.6."
        },
        {
            "name": "Set Elements Tag",
            "args": [
                "source",
                "tag",
                "xpath=."
            ],
            "doc": "Sets the tag of the specified elements.\n\nLike [Set Element Tag](#Set%20Element%20Tag) but sets the tag of all elements matching the given `xpath`.\n\nNew in Robot Framework 2.8.6."
        },
        {
            "name": "Set Elements Text",
            "args": [
                "source",
                "text=None",
                "tail=None",
                "xpath=."
            ],
            "doc": "Sets text and/or tail text of the specified elements.\n\nLike [Set Element Text](#Set%20Element%20Text) but sets the text or tail of all elements matching the given `xpath`.\n\nNew in Robot Framework 2.8.6."
        }
    ]
}